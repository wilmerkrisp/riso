package life.expert.riso.common;


import org.reactivestreams.Publisher;
import org.springframework.data.repository.NoRepositoryBean;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * <pre> * The type Forwarding reactive crud repository.
 *
 * Preconditions: none
 * Postconditions: none
 * Side effects: none
 * Tread safety: Not thread-safe
 * Immutable
 * Unconditionally thread-safe
 * Conditionally thread-safe
 * Not thread-safe
 * </pre>
 *
 * @param <T>  the type parameter
 * @param <ID> the type parameter
 */
@NoRepositoryBean
public abstract class ForwardingReactiveCrudRepository<T, ID>
    implements ReactiveCrudRepository<T, ID> {

  /**
   * Constructor for use by subclasses.
   */
  protected ForwardingReactiveCrudRepository() {
  }

  /**
   * Returns the backing delegate instance that methods are forwarded to. Abstract subclasses
   * generally override this method with an abstract method that has a more specific return type.
   * Concrete subclasses override this method to supply the instance being decorated.
   *
   * @param <S> the type parameter
   * @return the reactive crud repository
   */
  protected abstract <S extends T> ReactiveCrudRepository<S, ID> delegate();

  /**
   * Returns the string representation generated by the delegate's {@code toString} method.
   */
  @Override
  public String toString() {
    return delegate().toString();
  }

  @Override
  public <S extends T> Mono<S> save(final S s) {
    return delegate().save(s);
  }

  @Override
  public <S extends T> Flux<S> saveAll(final Iterable<S> iterable) {
    return delegate().saveAll(iterable);
  }

  @Override
  public <S extends T> Flux<S> saveAll(final Publisher<S> publisher) {
    return delegate().saveAll(publisher);
  }

  @Override
  public Mono<T> findById(final ID id) {
    return delegate().findById(id);
  }

  @Override
  public Mono<T> findById(final Publisher<ID> publisher) {
    return delegate().findById(publisher);
  }

  @Override
  public Mono<Boolean> existsById(final ID id) {
    return delegate().existsById(id);
  }

  @Override
  public Mono<Boolean> existsById(final Publisher<ID> publisher) {
    return delegate().existsById(publisher);
  }

  @Override
  public Flux<T> findAll() {
    return delegate().findAll();
  }

  @Override
  public Flux<T> findAllById(final Iterable<ID> iterable) {
    return delegate().findAllById(iterable);
  }

  @Override
  public Flux<T> findAllById(final Publisher<ID> publisher) {
    return delegate().findAllById(publisher);
  }

  @Override
  public Mono<Long> count() {
    return delegate().count();
  }

  @Override
  public Mono<Void> deleteById(final ID id) {
    return delegate().deleteById(id);
  }

  @Override
  public Mono<Void> deleteById(final Publisher<ID> publisher) {
    return delegate().deleteById(publisher);
  }

  @Override
  public Mono<Void> delete(final T t) {
    return delegate().delete(t);
  }

  @Override
  public Mono<Void> deleteAll(final Iterable<? extends T> iterable) {
    return delegate().deleteAll(iterable);
  }

  @Override
  public Mono<Void> deleteAll(final Publisher<? extends T> publisher) {
    return delegate().deleteAll(publisher);
  }

  @Override
  public Mono<Void> deleteAll() {
    return delegate().deleteAll();
  }
}

